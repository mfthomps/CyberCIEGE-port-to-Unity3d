\documentclass{article}
\usepackage{hyperref}
\usepackage[margin=0.5in]{geometry}


\title{CyberCIEGE UI Port to Unity: Work Plan}
\begin{document}
\maketitle
\raggedright
\setlength{\parindent}{1.0cm} % Default is 15pt.
\setlength{\parskip}{0.2cm} % Default is 15pt.

\section {Overview}
This document describes work necessary to create Unity UI elements for a revised CyberCIEGE game.
Additional background and overall strategy can be found in CyberCIEGEPortingReport.pdf 

CyberCIEGE has been split into two components: a simulation engine and a Unity based UI.  The former
manages all game play, network simulation, economy and game flow.  The UI elements will mostly present the 
3D environment and allow players to configure game objects via forms, menus, etc.

Existing 3D models and animations will be reused.  These have been defined in Maya 8.

CyberCIEGE is a collection of independent scenarios, each of which is fully expressed by a Scenario Definition File (SDF).
The intention is to resuse existing SDFs without modification.  This goal affects the UI implementation of game
geometry.

The initial goal is to create a functionally equivalent version of CyberCIEGE having a Unity UI in place of the
DirectX based UI.  The existing game can be obtained here: \newline
\url{https://my.nps.edu/documents/107523844/108048740/setup-demo.exe}

\section{General}
The CyberCIEGE Unity UI classes interact with the simulation engine via the IPCManagerScript {\tt SendRequest} method
and per-UI methods called by the IPCManager.  Most of the UI classes will present 
forms or other input schemes to allow users to change game state, e.g., add authorized users to a computer.  In these simple cases,
the UI class will package its revised state as XML and send that to the simulation engine via the 
IPCManager.  Many of the Unity UI classes already
include the desired data structures and methods for generating and sending XML.  
They lack useful UI elements for interacting with the user,
having only crude menu stubs.
Existing Unity stubs and management code is at \linebreak \url{https://github.com/mfthomps/CyberCIEGE-port-to-Unity3d}
\linebreak

With the exception of characters \footnote{...and tickers(scrollers), bubble speaks, fire and smoke...}, 
the UI elements do nothing about their state other than reflect it in the
forms/dialogs.  Characters, switch animation loops and walk paths as described below under "Users".  

A number of UI classes do not yet exist as Unity stubs, however they do exist as Java classes that 
provide forms and package XML suitable for 
sending via the IPCManager.  These Java classes will need to be converted to functionally equivalent Unity classes.
The specific Java classes that must be converted are identified in the UI Elements sections below.
These Java UIs were created using NetBeans and are at: \linebreak \url{https://gitlab.nps.edu/mfthomps/cyberciege/tree/master/Ccse/CCdialogs}

A few of the Java UI elements are defined at: \linebreak \url{https://gitlab.nps.edu/mfthomps/cyberciege/tree/master/Ccse/CCSDT.}

NOTE however that most of the Java in that directory is only used for the Scenario Development Kit, which is not being 
ported as part of this effort.

The UI classes get their initial state from XML files generated by the simulation engine when a scenaro begins.  Most of the UI
classes already include this initialization.

While most UI class interaction with the simulation engine by sending state change requests via the SendRequest method,
a handful also receive direction from the simulation engine via the IPCManager.  These are "pushed" to the UI classes
as seen in the Update method of the IPCManager.

The Unity UI has two scenes: a scenario selector described below under \ref{player}, and the scenario.
A Unity stub that manages loading of a selected scenario is in GameLoadBehavior.cs

As previously noted, much of the XML generated by the UI elements and sent to the IPCManager is already defined either
by Unity stubs or existing Java classes.  Other gaps can usually be filled by referencing \newline
\url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/ReplayLog.cpp}\newline
which will consume all the XML for the simulation engine.

\section {Environments and game space}
\subsection {Artwork}
The floor is defined as an x/y grid.
3D office environments are placed on that grid.
There are six office environments.  An SDF will name the office envirnonments used in the scenario. 
\begin{enumerate}
\item new big office (office5 / MS3OFFICE
\item new big military (office6 / MS3BASE)
\item old big office (mainoffice1 / MAINOFFICE1)
\item old big military (smalloffice / MAINOFFICE2)
\item home office 
\item work office 
\end{enumerate}

Each scenario includes a main office and a small number ofoffsite offices (which may include the old big military).

Object naming is defined in \linebreak \url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/shape.cpp}
\linebreak
\textbf{If it is not defined in shape.cpp, you can probably eignore it.}

Maya art is in https://gitlab.nps.edu/mfthomps/cyberciege/tree/master/art/MayaSourceArt

Office selection/naming in \linebreak 
\url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/CreateOffice.cpp}
\linebreak
Msc objects, e.g., sofas, are placed on that grid depending on the main office selection, as defined
in  \linebreak \url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/InitWorld.cpp}
\linebreak
Mapping of game names for computers/devices to Maya files can be derived from 
\linebreak
\url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/game/hardware.cpp}

\subsection{Geometry}
The new Unity geometry should be constructed to mimic the old CyberCIEGE geometry. The goal is to
run existing scenarios without modification.  Scenarios include predefined camera positions.

\subsection{Workspace}
The SDF includes a list of (index, x, y, {N/S/E/W}, furniture) tuples that define workspaces.
The {\tt furniture} values is desk/rack/??  or undefined.
Each workspace with defined furniture gets a corresponding object facing in the given direction (NOTE: inversions!) 

Computers/devices are each assigned an index denoting their location.  Precise location of object depends on
furniture and direction.  Users have defined workspaces.

Unity stub: WorkspaceScript.cs

\section{UI Elements}

\subsection{Computers}
Everything below is functionally stubbed in Unity.
Artwork/models from existing game.  
UI's available via right click on computer from existing game.
Player can move to different workspace
Player can "buy", selects which one and then workspace to place it.  Sends buy request to simulation engine.  Engine then sends
directive to IPCManager to instantiate new computer at location using named xml file.
Can recieve directive from IPCManager to remove.

\noindent Unity stubs:
\begin{itemize}
\item ComputerBehavior (inherits ComponentBehavior)
\item ComputerConfigure
\item ConfigurationSettings
\item ProceduralSettings
\item ACLConfigure
\item DACAccess
\item AssetBehavior
\end{itemize}
\noindent Java UIs
\begin{itemize}
\item Email encryption -- Email.java; EmailClient.java; EmailData.java
\item SSL -- in CCSDT: SSLClient.java; SSLData.java; SSLServer.java; 
\item VPN -- TestVPNConnection.java; VerifyCert.java; CertSign.java
\item VPN -- CCSDT: VPN.java; VPNClient.java; VPNdata.java; VPNpotentials.java; ValidateCert.java
\end{itemize}

\noindent To do:
\begin{itemize}
\item software purchase /remove
\end{itemize}

\subsection{Devices}
Artwork from existing game.
Players move/buy just like computers
\noindent Unity stubs:
\begin{itemize}
\item DeviceBehavior (inherits ComponentBehavior)
\end{itemize}
\noindent Java UIs
\begin{itemize}
\item Network filters  -- in CCSDT: AppFilter.java; Filter.Java; FilterDenialExceptions.java; FilterExceptions.java
\item VPN (Same as Computer)
\item IDS  -- IDSDialog.java; IDSData.java
\end{itemize}
\noindent No Java or Unity:
\begin{itemize}
\item Link encryptors -- see existing game screens: very simple.  select 1 of 4 keys and toggle encrypted/clear connections
\end{itemize}

\subsection{Zones}
These are areas of the x/y grid.  Each zone has different procedural and physical settings.
The player should be able to view a map of the zones, e.g., per the current game.
\noindent Unity stubs:
\begin{itemize}
\item ZoneBehavior
\item ZoneConfiguration
\item ProcedurealSettings (Same as Computer)
\item PhysicalSettings
\end{itemize}

\subsection{Users}
Reuse existing artwork and animations.
There are eight different characters and about a dozen animation sequences:
sit; stand; walk; type; pound keyboard; idle (look at nails,
stretch..)  Guards point gun..

Users walk calculated path to other users, other computers,
objects (e.g., water cooler), Zone access point.  Paths currently
reflected in 2d ascii art files per environment.
Walkable paths are defined in ascii art txt files in: \newline
\url{https://gitlab.nps.edu/mfthomps/cyberciege/tree/master/game/exec}
ms3office.txt; ms3base.txt; mainoffice.txt; smalloffice.txt; workoffice.txt; homeoffice.txt

Chairs move when users sit down.

Doors open when users approach.

The UI configuration limited to "training".

\noindent Unity stubs 
\begin{itemize}
\item UserBehavior
\item UserConfigure
\end{itemize}

IPCManager calls UserBehavior {\tt UpdateStatus} to set thoughts, happiness, productivity.  
Thoughts displayed when the user is selected, and bubble thoughts when hovered over.
Productivity controls whether typing or pounding keyboard.

The simulation engine has only a few cases in which it cares about user movement, and these
only occur in a small number of scenarios:
\begin{itemize}
	\item A "move user" trigger fires to assign a user a new workspace and optionally more the user
		there right way.  The IPCManager will receive aa move\_user directive with the new position index
and whether the character should be moved (or forced to walk.)
	\item A "vist user" trigger fires to cause a user to visit another user.  This case also requires
		the UI to notify the simulation engine when visit occurs, i.e., walking user reaches target user.
	\item A "visit computer" trigger fires to cause a user to visit a computer.  This case also requires feedback.
	\item Users passing through checkpoints, e.g, AI\_CheckChokePt in iconicAI.  These are only used
		within one suite of scenarios.  Design for this UI/Simulation interation is TBD.
\end{itemize}
Otherwise, the character movements are as defined in the iconicAI.cpp file.  Broadly, users go to their computers
if they have them, and wander if they do not.  If the user is not achieving goals (see iconicAI) and/or is unhappy,
they pound the keyboard, otherwise they type.

IPCManager will call UserBehavior to set walk destinations per move\_user and visit directives.
UserBehavior will call IPCManager to report entrance to zones and reaching
walk destinations.

IPC Manager will call UserBehavior to control bubble speaks; and smoke.

Character naming and textures defined in \newline
\url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/InitCharacter.cpp}

Animations defined in \newline
\url{https://gitlab.nps.edu/mfthomps/cyberciege/blob/master/ccsource/prog/iconicAI.cpp}

\subsubsection{IT Staff}
IT workers and guards are similar to users, but have no productivity goals. The will have walking 
destinations and bubble speech and thoughts.
ITStaffBehavior.cs

\subsection{Network connections}
Each computer/device pulldown menu will have options for connecting/disconnetion networks.
Additionally, there will be a network topology display via which network connections can
be modified.  See the Network tab in the current game.
Constraints on static computers and networks.

Unity stub: NetworkBehavior.cs

\subsubsection{Network discovery}
Java UI:  Discover.java; DiscoverData.java

\subsection{Attack log}
AttackLog.java
Running log of text. IPCManager calls to add.  Button color changes on new entries.
Includes a scenario-dependent varient: CasaLog.java

\subsection{Wireshark knockoff}
Java UIs:
CCPacket, CCPacketDetails; CCPacketReader; CyberChark

\subsection{Triggers}
\begin{itemize}
\item Objectives/Phases: Unity stub: ObjectivesBehavior
\item Camera movements: to user/computer/device/predefined positions.
\item Ticker messages (scrollers) and withdrawl of messages. Unity stub: ScrollingText.cs
\item Tool tips.  Unity stub: ToolTipScript.cs
\item Multiple choice questions -- ABC.java
\item Checklists -- CheckList.java
\item Yes/no  -- YesNo.java
\item Fire / Smoke 
\end{itemize}

\subsection {Scenario Player}
\label{player}
Unity stub: Assets/PlayerScripts/PlayerScript.cs
For selecting "campaign" and scenario.  Track which scenarios completed.
Manage prerequisites.  View logs.
Java at:
https://gitlab.nps.edu/mfthomps/cyberciege/tree/master/Ccse/SAT/Cplayer

\subsection{Encyclopedia}
Uses MS HTML workshop help.  Dozens of pages.  Triggers select default page if help is invoked.
 
\subsection{Msc}
Selecting users/computers/devices results in stargate rings

User clearance and background check dialogs (not per user).

Briefings

Help tips

Animated posters on walls.

Scenario replay controls (probably use existing Java).

View game log?

Game status with GameStatusBehavior.cs
\end{document}
